<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
<title>LowRes Coder Manual</title>
<style>
body {
	font-family: sans-serif;
    color: #000222;
    background-color: #F6F6F6;
}
.exm {
	font-weight: bold;
}
td, th {
    padding-right: 1em;
    vertical-align: top;
}
th {
    text-align: left;
}
a {
    color: #05ad96;
    text-decoration: none;
}
li {
    margin-bottom: 0.5em;
}
</style>
</head>

<body>
<h1 id="Getting-started">Getting started</h1>

<h2 id="_Tutorial">Tutorial</h2>
<p>Let's create your first own program! If you didn't create a new program yet, go to the overview of all programs and tap the Plus button in the top right corner. A new icon will appear at the end of the program list, called "Unnamed Program". Tap on it!</p>
<p>You will see now an empty text editor. Write the following lines, but replace MY NAME with your own name (keep the quotation marks):</p>
<pre class="exm">
DO
COLOR RND*16
TEXT 31,29,"MY NAME",1
WAIT 0.1
LOOP
</pre>
<p>Now tap on the Play button and you should see your name flashing in random colors! If you see an error message instead, check if you wrote something wrong. When you looked enough on your name, tap the Exit button (or the top left corner).</p>
<p>We should give a name to this program. Tap on the "Rename" button (in the bottom tool bar) and change the name to "My Name" or whatever you like.</p>
<p>How about sending your first program to a friend? Tap on the Share button (in the bottom left corner) and select Mail. Choose an address and tap the Send button. You may want to send it also to yourself to have a back-up.</p>
<p>You are ready now! Well, maybe you don't know programming yet, so you should read the other chapters, too! Also try all the other included programs and learn from them! You can duplicate them and experiment with the copies.</p>

<h2 id="_Publish">Publish your work in the community!</h2>
<p>LowRes Coder has an integrated community network. You can create you own profile page to post your programs or status updates. Follow other programmers to try and discuss their works.</p>
<p>When you created something and you are happy with it, you should share it! The Share menu offers you a "Community" action. Use it to post your program on your profile page. We keep an eye on most of the activity, if we like something, we will share it in the official LowRes Coder news!</p>

<h1 id="BASIC-principles">Basic principles</h1>

<h2 id="_Variables">Variables</h2>
<p>Variables are the names used to refer to values stored in the memory of a computer. They are used to hold the results of calculations in a program. The contents of a variable can be changed at any time.<br/>
You can choose any variable names in your programs, with the following restrictions: Allowed characters are the letters A to Z, the numbers 0 to 9 and the underscore "_", but no spaces. They must begin with a letter and cannot match with an existing LowRes Coder command or function name, but they can begin with one (see "Reserved keywords" chapter). <br/>
In LowRes Coder you don't have to declare variables. They start to exist automatically when they appear the first time in your program.</p>

<h3 id="_Numbers">Numbers</h3>
<p>A variable without any special sign in its name can store numbers, like 10, -2 or 3.5. Examples of number variable names:</p>
A, B2, X, Y, MY_SCORE, LIVES
<p>To assign a number to a variable, you write for example:</p>
<pre class="exm">A=10</pre>

<h3 id="_Strings">Strings</h3>
<p>String variables contain text rather than numbers. They are distinguished from number variables by the $ character at the end of their name. The $ is part of the variable name, so the variables A and A$ access different values. Examples of string variables:</p>
A$, B2$, MY_NAME$, TXT$
<p>You assign a text to a string variable like this:</p>
<pre class="exm">A$="HELLO"</pre>

<h3 id="_PERSIST" name="PERSIST">PERSIST</h3>
<pre>PERSIST x,y,z,...</pre>
<p>The PERSIST command declares the given variables as persistent. Their values are automatically stored on program exit, and loaded when PERSIST is called. The variables must be still unused at the moment of calling this command, so it should be placed at the beginning of a program. Persistent variables are useful for highscores or to save the current level. The following example shows different results on every start:</p>
<pre class="exm">
PERSIST NUM,T$
NUM=NUM+1
T$=T$+"A"
PRINT NUM
PRINT T$
</pre>

<h2 id="_Arrays">Arrays</h2>
<p>An array is a group of values of the same type, referenced by a single variable name. The individual values in an array are called elements. Array elements are variables also. They can be used in any BASIC command or function that uses variables.</p>
<h3 id="_DIM" name="DIM,DIM PERSIST,PERSIST">DIM</h3>
<pre>DIM [PERSIST] var(x,y,z,...)</pre>
<p>DIM defines a table of variables in your program. These tables may have as many dimensions as you want and you define for each dimension the highest element index.</p>
<pre class="exm">DIM TXT$(10),A(10,5),B(5,5,2)</pre>
<p>In order to access an element in the array you simply type the array name followed by the index numbers. These numbers are separated by commas and are enclosed between round brackets. Note that the element numbers of these arrays always start from zero.</p>
<pre class="exm">
DIM ARR(10)
ARR(0)=2
ARR(10)=5
PRINT ARR(10)
PRINT ARR(0)
</pre>
<p>Include the PERSIST keyword to make the arrays persistent. Their values are automatically stored on program exit, and loaded when DIM PERSIST is called. If the size of an array changes, stored values get cleared.</p>

<h2 id="_Arithmetic-operations" name="+,-,*,/,^,MOD">Arithmetic operations</h2>
<p>The following arithmetic operations can be used in a numeric expression:</p>
<table>
    <tr><th>Operator</th><th>Operation</th><th>Examples</th></tr>
    <tr><td>-</td><td>Unary negation</td><td>-X</td></tr>
    <tr><td>^</td><td>Power</td><td>X^Y</td></tr>
    <tr><td>/ and *</td><td>Divide and multiply</td><td>X/Y, X*Y</td></tr>
    <tr><td>MOD</td><td>Modulo (remainder of a devision)</td><td>X MOD Y</td></tr>
    <tr><td>+ and -</td><td>Plus and minus</td><td>X+Y, X-Y</td></tr>
</table>
<p>They are listed in the order of their priority how they are evaluated. Here is an example:</p>
<pre class="exm">PRINT 10+2*5-8/4+5^2</pre>
<p>This evaluates in the following order: 5^2, 2*5, 8/4 and then sums up the results to 43. If you want to change the order, you can enclose parts in round brackets:</p>
<pre class="exm">PRINT (10+2)*(5-8/4+5)^2</pre>

<h2 id="_Relational-operations" name="=,&lt;&gt;,&lt;,&gt;,&lt;=,&gt;=">Relational operations</h2>
<p>Relational operators are used to compare two values. The result of the comparison is either "true" (-1) or "false" (0).</p>
<table>
    <tr><th>Operator</th><th>Relation tested</th><th>Expression</th></tr>
    <tr><td>=</td><td>Equality</td><td>A=B</td></tr>
    <tr><td>&lt;&gt;</td><td>Inequality</td><td>A&lt;&gt;B</td></tr>
    <tr><td>&lt;</td><td>Less than</td><td>A&lt;B</td></tr>
    <tr><td>&gt;</td><td>Greater than</td><td>A&gt;B</td></tr>
    <tr><td>&lt;=</td><td>Less than or equal to</td><td>A&lt;=B</td></tr>
    <tr><td>&gt;=</td><td>Greater than or equal to</td><td>A&gt;=B</td></tr>
</table>

<h2 id="_Logical-operations" name="NOT,AND,OR,XOR">Logical operations</h2>
<p>The results of the following operations are binary (bit by bit).</p>
<table>
    <tr><th>Operator</th><th>Value</th><th>Value</th><th>Result</th></tr>
    <tr><td>NOT</td><td>X</td><td></td><td>NOT X</td></tr>
    <tr><td></td><td>true</td><td></td><td>false</td></tr>
    <tr><td></td><td>false</td><td></td><td>true</td></tr>
    <tr><td>AND</td><td>X</td><td>Y</td><td>X AND Y</td></tr>
    <tr><td></td><td>true</td><td>true</td><td>true</td></tr>
    <tr><td></td><td>true</td><td>false</td><td>false</td></tr>
    <tr><td></td><td>false</td><td>true</td><td>false</td></tr>
    <tr><td></td><td>false</td><td>false</td><td>false</td></tr>
    <tr><td>OR</td><td>X</td><td>Y</td><td>X OR Y</td></tr>
    <tr><td></td><td>true</td><td>true</td><td>true</td></tr>
    <tr><td></td><td>true</td><td>false</td><td>true</td></tr>
    <tr><td></td><td>false</td><td>true</td><td>true</td></tr>
    <tr><td></td><td>false</td><td>false</td><td>false</td></tr>
    <tr><td>XOR</td><td>X</td><td>Y</td><td>X XOR Y</td></tr>
    <tr><td></td><td>true</td><td>true</td><td>false</td></tr>
    <tr><td></td><td>true</td><td>false</td><td>true</td></tr>
    <tr><td></td><td>false</td><td>true</td><td>true</td></tr>
    <tr><td></td><td>false</td><td>false</td><td>false</td></tr>
</table>
<p>As in BASIC "true" is -1 (all bits set) and "false" is 0 (no bit set), these operators can be used for logical expressions...</p>
<pre class="exm">IF A=0 OR B=1 THEN PRINT "OK"</pre>
<p>...and also for bit manipulations:</p>
<pre class="exm">
A=15 OR 256
PRINT A
REM >>271
</pre>

<h2 id="_String-operations" name="+">String operations</h2>
<p>You can concatenate strings with the plus operation.</p>
<pre class="exm">
A$="LOW"+"RES"+" CODER"
PRINT A$
REM >>LOWRES CODER
</pre>
<p>If you add together string and number variables or constants, the numbers get converted to strings automatically.</p>
<pre class="exm">
L=2
A$="LIVES: "+L
PRINT A$
REM >>LIVES: 2
</pre>

<h2 id="_Parameters">Parameters</h2>
<p>The values you enter into a LowRes Coder command are known as parameters, for example:</p>
<pre class="exm">
COLOR 2
TEXT X,Y,"HI"
</pre>
<p>The parameters in these commands are 2, X, Y and "HI".</p>

<h2 id="_Labels">Labels</h2>
<p>Labels are a way of marking lines in your programs. They can have any names with the same restrictions as variable names have, and are followed by the ":" (colon) character.</p>
<pre class="exm">
TESTLABEL:
PRINT "HELLO"
GOTO TESTLABEL
</pre>

<h1 id="Simple-commands">Simple commands</h1>

<h3 id="_PRINT" name="PRINT">PRINT</h3>
<pre>PRINT value</pre>
<p>PRINT writes <i>value</i> on the screen, where <i>value</i> can be also a string or any expression. This is a simplified version of PRINT in the classic BASIC language and exists basically for testing. In a normal graphics based program you should prefer the TEXT command.</p>
<pre class="exm">
PRINT "HELLO"
PRINT 2+2
</pre>


<h3 id="_INPUT" name="INPUT">INPUT</h3>
<p>In the classic BASIC language, this command is the main way of getting user input by the keyboard. As LowRes Coder doesn't support keyboard, this command does not exist here.</p>

<h3 id="_WAIT" name="WAIT,TAP">WAIT</h3>
<pre>WAIT seconds [TAP]</pre>
<p>WAIT pauses the execution of the program for the time set by the <i>seconds</i> parameter. The shortes wait time is 0.04 seconds. If you add the TAP keyword, the waiting will be interrupted by any tap on a gamepad button.</p>
<p>This command has an important side effect: It updates the screen. If you draw something in a loop, you won't see it on screen until you call WAIT (or the program ends).</p>
<pre class="exm">
FOR X=0 TO 63
  PLOT X,31
  WAIT 0.1
NEXT X
</pre>

<h3 id="_END" name="END">END</h3>
<pre>END</pre>
<p>Stops the execution of the program. This can be called in any place of your program.</p>

<h3 id="_REM" name="REM">REM</h3>
<pre>REM comment</pre>
<p>If a line starts with REM (remark), it's completely ignored by the program, so you can write comments into your code.</p>
<pre class="exm">
REM THIS IS A TEST PROGRAM
REM WRITTEN BY TIMO KLOSS
PRINT "HELLO"
REM SHOW MORE TEXT...
PRINT "BYE"
</pre>

<h3 id="_TRUE" name="TRUE">=TRUE</h3>
<pre>v=TRUE</pre>
<p>TRUE is equal to -1. It's useful for assigning it to a variable.</p>

<h3 id="_FALSE" name="FALSE">=FALSE</h3>
<pre>v=FALSE</pre>
<p>FALSE is equal to 0.</p>

<h1 id="Graphics">Graphics</h1>

<p>LowRes Coder runs your programs on a virtual screen with 64x64 pixels and 16 colors. With the following commands you can draw on this screen.</p>

<h3 id="_COLOR" name="COLOR">COLOR</h3>
<pre>COLOR index</pre>
<p>COLOR sets the current drawing color, where <i>index</i> can have the following values:</p>
<table>
<tr><td>0</td><td>black</td><td>8</td><td>yellow</td></tr>
<tr><td>1</td><td>white</td><td>9</td><td>green</td></tr>
<tr><td>2</td><td>light gray</td><td>10</td><td>dark green</td></tr>
<tr><td>3</td><td>dark gray</td><td>11</td><td>cyan</td></tr>
<tr><td>4</td><td>red</td><td>12</td><td>blue</td></tr>
<tr><td>5</td><td>dark red</td><td>13</td><td>dark blue</td></tr>
<tr><td>6</td><td>brown</td><td>14</td><td>magenta</td></tr>
<tr><td>7</td><td>orange</td><td>15</td><td>purple</td></tr>
</table>
<pre class="exm">
FOR I=1 TO 15
  COLOR I
  PRINT "COLOR "+I
NEXT I
</pre>
<p>These default colors can be changed with the PALETTE command.</p>

<h3 id="_CLS" name="CLS">CLS</h3>
<pre>CLS [color]</pre>
<p>CLS clears and fills the whole screen with <i>color</i>. Check the color table of the COLOR command.</p>
<pre class="exm">
FOR I=0 TO 15
  CLS I
  WAIT 0.1
NEXT I
</pre>

<h3 id="_PLOT" name="PLOT">PLOT</h3>
<pre>PLOT x,y</pre>
<p>PLOT draws a pixel at the coordinates <i>x,y</i>.</p>
<pre class="exm">
DO
  COLOR RND*16
  PLOT RND*64,RND*64
  WAIT 0.1
LOOP
</pre>

<h3 id="_POINT" name="POINT">=POINT</h3>
<pre>v=POINT(x,y)</pre>
<p>POINT returns the color index at the coordinates <i>x,y</i>.</p>
<pre class="exm">
    COLOR 11
    PLOT 63,0
    PRINT POINT(63,0)
    PRINT POINT(63,1)
    REM >>11
    REM >>0
</pre>

<h3 id="_LINE" name="LINE">LINE</h3>
<pre>LINE x1,y1 TO x2,y2</pre>
<p>LINE draws a line from the coordinates <i>x1,y1</i> to the coordinates <i>x2,y2</i>.</p>
<pre class="exm">
DO
  COLOR RND*16
  LINE RND*64,RND*64 TO RND*64,RND*64
  WAIT 0.1
LOOP
</pre>

<h3 id="_BOX" name="BOX">BOX</h3>
<pre>BOX x1,y1 TO x2,y2</pre>
<p>BOX draws an unfilled rectangle with the diagonal corners at the coordinates <i>x1,y1</i> and <i>x2,y2</i>.</p>
<pre class="exm">
BOX 0,0 TO 63,63
</pre>

<h3 id="_BAR" name="BAR">BAR</h3>
<pre>BAR x1,y1 TO x2,y2</pre>
<p>BAR paints a filled rectangle with the diagonal corners at the coordinates <i>x1,y1</i> and <i>x2,y2</i>.</p>
<pre class="exm">
BAR 2,20 TO 61,43
</pre>

<h3 id="_CIRCLE" name="CIRCLE,PAINT">CIRCLE</h3>
<pre>CIRCLE x,y,radius [PAINT]</pre>
<p>CIRCLE draws a circle with the coordinates <i>x,y</i> as center and the given <i>radius</i>. With the optional PAINT keyword, the circle gets filled.</p>
<pre class="exm">
COLOR 7
CIRCLE 32,32,24 PAINT
COLOR 8
CIRCLE 32,32,20
</pre>

<h3 id="_PAINT" name="PAINT">PAINT</h3>
<pre>PAINT x,y</pre>
<p>PAINT flood fills a closed area, starting at the coordinates <i>x,y</i>.</p>
<pre class="exm">
COLOR 8
BOX 2,20 TO 61,43
LINE 2,20 TO 61,43
COLOR 7
PAINT 60,21
COLOR 9
PAINT 3,42
</pre>

<h3 id="_TEXT" name="TEXT">TEXT</h3>
<pre>TEXT x,y,text$[,align]</pre>
<p>TEXT draws the string <i>text$</i> at the coordinates <i>x,y</i>. Note that <i>text$</i> can also be a number, it will be converted automatically into a string.</p>
<pre class="exm">TEXT 0,0,"HELLO"</pre>
<p>With the optional parameter <i>align</i> the text can be drawn in different ways:</p>
<table>
<tr><td>0</td><td>Left aligned (default)</td></tr>
<tr><td>1</td><td>Centered</td></tr>
<tr><td>2</td><td>Right aligned</td></tr>
</table>
<pre class="exm">TEXT 32,0,"CENTERED TEXT",1</pre>

<h3 id="_TEXTWIDTH" name="TEXT WIDTH,TEXT,WIDTH">=TEXT WIDTH</h3>
<pre>v=TEXT WIDTH(text$)</pre>
<p>TEXT WIDTH returns the width of <i>text$</i> in pixels as it would be drawn with the TEXT command.</p>
<pre class="exm">
T$="HELLO"
W=TEXT WIDTH(T$)
WHILE X&lt;63
  COLOR 1+RND*15
  TEXT X,0,T$
  X=X+W
WEND
</pre>

<h3 id="_SCROLL" name="SCROLL">SCROLL</h3>
<pre>SCROLL x1,y1 TO x2,y2,dx,dy</pre>
<p>SCROLL moves the rectangular screen area between <i>x1,y1</i> and <i>x2,y2</i> horizontally by <i>dx</i> and vertically by <i>dy</i> pixels.</p>
<pre class="exm">
DO
  PLOT RND*63,1+RND*63
  SCROLL 0,0 TO 63,63,-2,1
  WAIT 0.04
LOOP
</pre>

<h3 id="_LAYER" name="LAYER">LAYER</h3>
<pre>LAYER number</pre>
<p>The screen of LowRes Coder has two layers. Layer 0 is in the background and usually the main layer. Layer 1 is in the foreground and it's transparent in all pixels with color 0. When you set the current layer with this command, all following drawing commands render on the selected layer.</p>
<pre class="exm">
LAYER 1
LINE 0,0 TO 63,63
LAYER 0
DO
  COLOR RND*16
  BAR 0,26 TO 63,36
  WAIT 0.1
LOOP
</pre>

<h3 id="_GET" name="GET">GET</h3>
<pre>GET x1,y1 TO x2,y2</pre>
<p>Copies the rectangular screen area between <i>x1,y1</i> and <i>x2,y2</i> to a buffer. Use the PUT command to draw it on the screen.</p>

<h3 id="_PUT" name="PUT">PUT</h3>
<pre>PUT x,y[,sx,sy,sw,sh[,transparency]]</pre>
<pre>PUT x,y[,transparency]</pre>
<p>Draws the screen area copied by the GET command on the screen at the coordinates <i>x,y</i>. By default the complete copied area will be drawn. With the additional parameters you can draw a smaller part of the source image. With <i>sx</i> and <i>sy</i> you specify the top left corner of the source image, <i>sw</i> is the width and <i>sh</i> the height. If <i>transparency</i> is given and different from -1, the image is drawn with <i>transparency</i> as transparent color.</p>
<pre class="exm">
COLOR 4
BAR 10,10 TO 30,20
COLOR 8
BAR 12,12 TO 28,18
GET 10,10 TO 30,20
PUT 15,25
PUT 20,40,0,0,10,5
PUT 40,40,11,6,10,5
</pre>

<h3 id="_PALETTE" name="PALETTE">PALETTE</h3>
<pre>PALETTE index,value</pre>
<p>Changes the value of color <i>index</i> in the palette. There are 64 possible color values, mixed with each 4 shades of red, green and blue. You can calculate <i>value</i> like this:</p>
<pre class="exm">VALUE = RED * 16 + GREEN * 4 + BLUE</pre>
<p>(RED, GREEN and BLUE are values from 0 to 3). When you call this command all pixels on the screen with that index in the palette will change their color.</p>

<h3 id="_PALETTECLEAR" name="PALETTE CLEAR,PALETTE,CLEAR">PALETTE CLEAR</h3>
<pre>PALETTE CLEAR</pre>
<p>Resets the palette to the default colors (see COLOR command).</p>

<h3 id="_PALETTEFUNC" name="PALETTE">=PALETTE</h3>
<pre>v=PALETTE(index)</pre>
<p>This function returns the current value of the color <i>index</i> from the palette. You can get the RED, GREEN and BLUE values like this:</p>
<pre class="exm">
RED = INT(VALUE / 16)
GREEN = INT(VALUE / 4) MOD 4
BLUE = VALUE MOD 4
</pre>

<h1 id="Control-structures">Control structures</h1>

<p>LowRes Coder offers several commands to control the execution of your programs. You can repeat sequences of code, execute different code depending on decisions and jump between program parts.</p>

<h3 id="_IF" name="IF,THEN,ELSE,ELSE IF,END IF,END">IF ... THEN ... ELSE ... END IF</h3>
<pre>IF condition THEN command [ELSE command]</pre>
<pre>
IF condition THEN
commands
[ELSE
commands]
END IF
</pre>
<p>The IF command allows you to make decisions in a program. Depending on the result different commands are executed. The <i>condition</i> can be any list of tests including AND and OR. There is the single line version, which allows only one command after THEN and optionally one command after ELSE:</p>
<pre class="exm">
FOR I=1 TO 4
  IF I&lt;3 THEN PRINT "SMALL" ELSE PRINT "BIG"
  IF I=4 THEN PRINT "END"
NEXT I
</pre>
<p>If you need to execute more than one command, an IF ... END IF block can be used. ELSE blocks are optional.</p>
<pre class="exm">
A=1
IF A=0 THEN
  PRINT "A IS ZERO"
  PRINT "NO?"
ELSE IF A=1 THEN
  PRINT "A IS ONE"
  PRINT "NO?"
ELSE
  PRINT "A IS WHAT?"
END IF
</pre>

<h3 id="_GOTO" name="GOTO">GOTO</h3>
<pre>GOTO label</pre>
<p>GOTO makes the program continue in the line marked with <i>label</i>. While it's possible to jump out of a loop (WHILE/WEND, DO/LOOP,...) or out of an IF block, it's an error to jump from outside to inside.</p>
<pre class="exm">
PRINT "START"
GOTO GAMELEVEL
GAMEOVER:
PRINT "GAME OVER"
END
GAMELEVEL:
PRINT "PLAYING"
GOTO GAMEOVER
</pre>

<h3 id="_GOSUB" name="GOSUB">GOSUB</h3>
<pre>GOSUB label</pre>
<p>GOSUB is similar to GOTO, but it remembers the current execution position. When RETURN is called, the program jumps back to the line where GOSUB was called.</p>
<pre class="exm">
FOR I=1 TO 5
  GOSUB SHOWNUMBER
NEXT I
END
SHOWNUMBER:
PRINT "NUMBER "+I
RETURN
</pre>

<h3 id="_RETURN" name="RETURN">RETURN</h3>
<pre>RETURN [label]</pre>
<p>The execution of the program returns to the last GOSUB call.</p>
<p>The <i>label</i> parameter may be included in the RETURN command to return to a specific label from the subroutine. This label must be accessible from the position of the previously called GOSUB command.</p>
<pre class="exm">
FOR I=1 TO 5
  GOSUB SHOWNUMBER
NEXT I
END
SHOWNUMBER:
IF I=4 THEN RETURN GAMEOVER
PRINT "NUMBER "+I
RETURN
GAMEOVER:
PRINT "GAME OVER"
</pre>


<h3 id="_FOR" name="FOR,STEP,NEXT">FOR ... NEXT</h3>
<pre>
FOR index=first TO last [STEP increment]
commands
NEXT [index]
</pre>
<p>A FOR/NEXT command repeats a list of commands a specific number of times. <i>index</i> is a counter variable that will be incremented after each loop. At the start of the loop, this counter will be set to <i>first</i>. Now all commands until NEXT are performed. <i>increment</i> will be added to the counter every time NEXT is reached. If STEP is omitted, the increment will be 1. The loop repeats as long as the counter is not greater than <i>last</i>.</p>
<pre class="exm">
FOR I=1 TO 10 STEP 2
  PRINT I
NEXT I
</pre>
<p>Note that <i>increment</i> can be negative to count backwards. In this case the loop will be finished when the counter is less than <i>last</i>.</p>
<pre class="exm">
FOR I=5 TO 1 STEP -1
  PRINT I
NEXT I
</pre>
<p>As all other loops, FOR/NEXT loops can be placed inside of others.</p>
<pre class="exm">
FOR X=0 TO 5
  FOR Y=0 TO 5
    CLS 0
    PLOT X,Y
    WAIT 0.1
  NEXT Y
NEXT X
</pre>

<h3 id="_REPEAT" name="REPEAT,UNTIL">REPEAT ... UNTIL</h3>
<pre>
REPEAT
commands
UNTIL condition
</pre>
<p>A REPEAT/UNTIL command repeats a list of commands until <i>condition</i> is true.</p>
<pre class="exm">
REPEAT
  A=INT(RND*10)
  PRINT A
UNTIL A=0
</pre>

<h3 id="_WHILE" name="WHILE,WEND">WHILE ... WEND</h3>
<pre>
WHILE condition
commands
WEND
</pre>
<p>A WHILE/WEND command repeats a list of commands as long as <i>condition</i> is true.</p>
<pre class="exm">
WHILE A&lt;10
  PRINT A
  A=A+1
WEND
</pre>

<h3 id="_DO" name="DO,LOOP">DO ... LOOP</h3>
<pre>
DO
commands
LOOP
</pre>
<p>A DO/LOOP command repeats a list of commands forever. You can still exit from the loop by calling EXIT.</p>
<pre class="exm">
DO
  COLOR RND*16
  PRINT "FOREVER"
LOOP
</pre>

<h3 id="_EXIT" name="EXIT">EXIT</h3>
<pre>EXIT</pre>
<p>EXIT makes the program jump out of the current loop (WHILE/WEND, DO/LOOP,...).</p>
<pre class="exm">
DO
  C=INT(RND*16)
  COLOR C
  PRINT "LOOPING"
  IF C=15 THEN EXIT
LOOP
PRINT "DONE"
</pre>

<h3 id="_ONENDGOTO" name="ON END,ON END GOTO,ON,END,GOTO">ON END GOTO</h3>
<pre>ON END GOTO label</pre>
<pre>ON END</pre>
<p>This command adds special handling for the moment the user taps the exit button. Instead of just quitting the program, it will jump to <i>label</i>. The program has 2 seconds then to do something before calling END. You can use this for example to transfer data with WRITE.</p>
<pre class="exm">
ON END GOTO FIN
DO
  PRINT "EXIT PROGRAM!"
  WAIT 1
LOOP
FIN:
PRINT "BYE!"
WAIT 2
</pre>
<p>ON END (without GOTO) clears the label and activates the normal behavior again.</p>

<h3 id="_ONPAUSEGOTO" name="ON PAUSE,ON PAUSE GOTO,ON,PAUSE,GOTO">ON PAUSE GOTO</h3>
<pre>ON PAUSE GOTO label</pre>
<pre>ON PAUSE</pre>
<p>This command adds special handling for the moment the user taps the pause button. Instead of pausing the program, it will jump to <i>label</i>.</p>
<pre class="exm">
GAMEPAD 1
GAME:
ON PAUSE GOTO GAMEMENU
CLS
DO
  COLOR RND*16
  TEXT 0,20,"PLAYING..."
  TEXT 0,26,"PRESS PAUSE"
  WAIT 0.1
LOOP
GAMEMENU:
ON PAUSE GOTO GAME
CLS
DO
  COLOR RND*16
  TEXT 0,20,"PAUSED"
  TEXT 0,26,"PRESS PAUSE"
  TEXT 0,32,"TO CONTINUE"
  WAIT 0.1
LOOP
</pre>
<p>ON PAUSE (without GOTO) clears the label and activates the normal behavior again.</p>

<h1 id="User-input">User input</h1>

<p>LowRes Coder can show a virtual game pad on the screen. Use these commands to handle the user input.</p>

<h3 id="_GAMEPAD" name="GAMEPAD">GAMEPAD</h3>
<pre>GAMEPAD players</pre>
<p>GAMEPAD shows game controls (a direction pad and two buttons) for the given number of players. Currently only one player is supported. If <i>players</i> is 0, the controls will be hidden and the complete screen works like button A.</p>

<h3 id="_UP" name="UP">=UP</h3>
<pre>v=UP(player)</pre>
<p>Returns TRUE if up is currently pressed on the direction pad of the given player. <i>player</i> starts with 0 for the first one.</p>

<h3 id="_DOWN" name="DOWN">=DOWN</h3>
<pre>v=DOWN(player)</pre>
<p>Returns TRUE if down is currently pressed on the direction pad of the given player. <i>player</i> starts with 0 for the first one.</p>

<h3 id="_LEFT" name="LEFT">=LEFT</h3>
<pre>v=LEFT(player)</pre>
<p>Returns TRUE if left is currently pressed on the direction pad of the given player. <i>player</i> starts with 0 for the first one.</p>

<h3 id="_RIGHT" name="RIGHT">=RIGHT</h3>
<pre>v=RIGHT(player)</pre>
<p>Returns TRUE if right is currently pressed on the direction pad of the given player. <i>player</i> starts with 0 for the first one.</p>

<h3 id="_BUTTON" name="BUTTON,BUTTON TAP,TAP">=BUTTON</h3>
<pre>v=BUTTON [TAP](player[,button])</pre>
<p>Returns TRUE if the A or B button of the given player is currently pressed. <i>player</i> starts with 0 for the first one. If <i>button</i> is omitted or 0, any button (A and B) is checked. 1 checks only the A button, 2 checks only the B button.</p>
<p>With the optional TAP keyword the function returns TRUE only once for one tap on the button, and not as long as the button is pressed.</p>

<h1 id="Sound">Sound</h1>
<p>LowRes Coder has three independent sound generators, called voices. Each of them has a queue which can store and reproduce sound sequences without blocking the execution of the program.</p>

<h3 id="_SOUND" name="SOUND">SOUND</h3>
<pre>SOUND voice,pitch,duration[,instr]</pre>
<p>Plays a sound through the given <i>voice</i> (a value from 0 to 2). <i>pitch</i> sets the tone to play:</p>
<table>
    <tr><th>Note</th><th colspan="8">Pitch (with different octaves)</th></tr>
    <tr><th>C</th><td>1</td><td>13</td><td>25</td><td>37</td><td>49</td><td>61</td><td>73</td><td>85</td></tr>
    <tr><th>C#</th><td>2</td><td>14</td><td>26</td><td>38</td><td>50</td><td>62</td><td>74</td><td>86</td></tr>
    <tr><th>D</th><td>3</td><td>15</td><td>27</td><td>39</td><td>51</td><td>63</td><td>75</td><td>87</td></tr>
    <tr><th>D#</th><td>4</td><td>16</td><td>28</td><td>40</td><td>52</td><td>64</td><td>76</td><td>88</td></tr>
    <tr><th>E</th><td>5</td><td>17</td><td>29</td><td>41</td><td>53</td><td>65</td><td>77</td><td>89</td></tr>
    <tr><th>F</th><td>6</td><td>18</td><td>30</td><td>42</td><td>54</td><td>66</td><td>78</td><td>90</td></tr>
    <tr><th>F#</th><td>7</td><td>19</td><td>31</td><td>43</td><td>55</td><td>67</td><td>79</td><td>91</td></tr>
    <tr><th>G</th><td>8</td><td>20</td><td>32</td><td>44</td><td>56</td><td>68</td><td>80</td><td>92</td></tr>
    <tr><th>G#</th><td>9</td><td>21</td><td>33</td><td>45</td><td>57</td><td>69</td><td>81</td><td>93</td></tr>
    <tr><th>A</th><td>10</td><td>22</td><td>34</td><td>46</td><td>58</td><td>70</td><td>82</td><td>94</td></tr>
    <tr><th>A#</th><td>11</td><td>23</td><td>35</td><td>47</td><td>59</td><td>71</td><td>83</td><td>95</td></tr>
    <tr><th>B</th><td>12</td><td>24</td><td>36</td><td>48</td><td>60</td><td>72</td><td>84</td><td>96</td></tr>
</table>
<p>A sound with <i>pitch</i> 0 is silent and can be used as a pause.</p>
<p>The <i>duration</i> of the note is set in 1/24 seconds. Each voice has an own queue, so sounds are played one after another without blocking the program. A maximum of 1023 sounds can be queued in each voice. If <i>duration</i> is 0, the queue is cleared and the sound will start immediately and won't stop until the voice starts another sound or SOUND OFF is called.</p>
<p>You can set an instrument with the <i>instr</i> parameter (see DEF SOUND), otherwise the last instrument of the voice will be kept. By default the instruments are already set up with different waveforms.</p>
<pre class="exm">
SOUND 0,49,12,1
SOUND 0,53,12
SOUND 0,56,12
SOUND 0,61,24,0
</pre>

<h3 id="_SOUNDOFF" name="SOUND OFF,SOUND,OFF">SOUND OFF</h3>
<pre>SOUND OFF [voice]</pre>
<p>Stops the sound of <i>voice</i> and clears its queue. If the <i>voice</i> parameter is omitted, all voices will be stopped.</p>

<h3 id="_SOUNDEND" name="SOUND END,SOUND,END">=SOUND END</h3>
<pre>v=SOUND END[(voice)]</pre>
<p>This function returns TRUE, if the queue of the given <i>voice</i> is empty. A queue is already empty when its last sound is still playing. If the parameter is omitted, all voices are checked.</p>
<pre class="exm">
DO
  IF SOUND END THEN
    SOUND 0,49,12,1
    SOUND 0,53,12
    SOUND 0,56,12
    SOUND 0,61,24,0
    SOUND 0,0,12
  END IF
  WAIT 0.1
LOOP
</pre>

<h3 id="_DEFSOUND" name="DEF SOUND,DEF,SOUND">DEF SOUND</h3>
<pre>DEF SOUND instr,wave[,pulse[,time]]</pre>
<p>Defines one of up to 64 different instruments which can be used with SOUND, so <i>instr</i> can be a value from 0 to 63.</p>
<p>The base of an instrument is the waveform, which is set with the <i>wave</i> parameter:</p>
<table>
    <tr><td>0</td><td>sawtooth wave</td></tr>
    <tr><td>1</td><td>triangle wave</td></tr>
    <tr><td>2</td><td>pulse wave</td></tr>
    <tr><td>3</td><td>noise</td></tr>
</table>
<p>If the waveform is "pulse wave" (2), you can set a pulse width between 0.0 and 1.0 with the <i>pulse</i> parameter. A value of 0.5 results in a square wave. For other waveforms this parameter is ignored.</p>
<p>The <i>time</i> parameter defines the maximum duration of the sound in seconds. If a SOUND command sets a longer duration, the voice will play the maximum duration and then it will be silent until the next sound in the queue. Omit the parameter to play sounds always in full duration.</p>

<h3 id="_DEFSOUNDLINE" name="DEF SOUND LINE,DEF SOUND,DEF,SOUND,LINE">DEF SOUND LINE</h3>
<pre>DEF SOUND LINE instr,time,pitch,pulse</pre>
<p>Sets additional values for the instrument number <i>instr</i>. It makes sounds change over the given <i>time</i> (in seconds). Call this command (if needed) always after the DEF SOUND of the same instrument, otherwise the values will be reset.</p>
<p>The sound will start with <i>pitch</i> added to the note's original value (or subtracted if <i>pitch</i> is negative). The <i>pulse</i> value is added to pulse width of the original sound (only if the waveform is "pulse").</p>
<p>Pitch and pulse width will return in the given time to its original values.</p>
<pre class="exm">
DEF SOUND 0,2,0,0.2
DEF SOUND LINE 0,0.1,12,0
SOUND 0,30,12,0
SOUND 0,42,12
SOUND 0,54,12
</pre>

<h1 id="Sprites">Sprites</h1>

<p>Sprites are graphical objects with 8x8 pixels and 3 colors (plus a transparent background color). They are shown on an own layer and don't affect the normal graphic layer used for drawing. They can be moved and animated very easily, that's why they are perfect for game objects. Sprites are not designed with the normal graphic commands, but they are defined by bitmaps. LowRes Coder can show up to 16 sprites at once.</p>

<h3 id="_DEFSPRITE" name="DEF SPRITE,DEF,SPRITE">DEF SPRITE</h3>
<pre>DEF SPRITE image,data</pre>
<p>Defines a sprite image and stores it as number <i>image</i>. Possible values range from 0 to 63. <i>data</i> is the name of an array (without index numbers) which has 16 elements and contains the bitmap data. Usually these arrays are loaded from DATA commands, like this:</p>
<pre class="exm">
DIM ARR(15)
FOR I=0 TO 15
  READ ARR(I)
NEXT I
DEF SPRITE 0,ARR
SPRITE 0,10,10,0
SPRITE 1,20,20,0
SPRITE 2,30,30,0
DATA 5,80,21,84,105,105,105,105
DATA 85,85,127,253,31,244,5,80
</pre>
<p>Don't be scared of the numbers, you can use the included program Sprite Designer to draw your images and transfer them to source code.</p>
<p>Here is a little explanation of the format: The numbers in the data array are bytes. A sprite has 8x8 pixels and each pixel has two bits to define the color, that makes two bytes per line. Lines are stored from top to bottom, so in the end we have 16 bytes.</p>

<h3 id="_SPRITE" name="SPRITE">SPRITE</h3>
<pre>SPRITE number,[x],[y],[image]</pre>
<p>Shows a sprite on the screen or changes the position or the image. <i>number</i> is the identification number of the sprite and can have a value from 0 to 15. The sprite will be shown at the screen coordinates <i>x,y</i> with the given <i>image</i>. See the example of DEF SPRITE.</p>
<p>If a sprite is already on the screen, it is possible to change only specific parameters and keeping others. Just omit the parameters you don't want to change, but don't remove the commas!</p>
<pre class="exm">
REM SHOW SPRITE
SPRITE 0,10,10,0
REM CHANGE Y POSITION
SPRITE 0,,15,
REM CHANGE IMAGE
SPRITE 0,,,1
</pre>

<h3 id="_SPRITEOFF" name="SPRITE OFF,SPRITE,OFF">SPRITE OFF</h3>
<pre>SPRITE OFF [number]</pre>
<p>Removes the sprite with the given <i>number</i> from the screen. If the parameter is omitted, all sprites are removed.</p>

<h3 id="_SPRITEPALETTE" name="SPRITE PALETTE,SPRITE,PALETTE">SPRITE PALETTE</h3>
<pre>SPRITE PALETTE number,[c1],[c2],[c3]</pre>
<p>Sets the colors <i>c1, c2,</i> and <i>c3</i> for a sprite. Although a sprite image can only have three colors, each sprite on the screen can have its own color palette. See the available color numbers of the COLOR command. Single color parameters can be omitted to keep the current values of the sprite.</p>
<pre class="exm">
REM ORANGE, WHITE, RED
SPRITE PALETTE 0,7,1,4
REM CHANGE ONLY COLOR 3
SPRITE PALETTE 0,,,5
</pre>

<h3 id="_SPRITEXYI" name="SPRITE X,SPRITE Y,SPRITE I,SPRITE,X,Y,I">=SPRITE X/Y/I</h3>
<pre>x=SPRITE X(number)</pre>
<pre>y=SPRITE Y(number)</pre>
<pre>i=SPRITE I(number)</pre>
<p>These functions return current values of the given sprite <i>number</i>. X and Y are the coordinates, I is the image. If the sprite is currently not visible, <i>SPRITE I</i> will return -1.</p>

<h3 id="_SPRITEHIT" name="SPRITE HIT,SPRITE,HIT">=SPRITE HIT</h3>
<pre>v=SPRITE HIT(number[,other [TO last]])</pre>
<p>Returns TRUE if sprite <i>number</i> collides with another sprite (which means that pixels overlap). If no more parameters are given, it will check with all other visible sprites. If the <i>other</i> parameter is added, it will check only with that sprite number. If all parameters are given, it will check with all sprites between number <i>other</i> and <i>last</i>.</p>
<pre class="exm">
REM COLL. SPRITE 0 WITH ANY
IF SPRITE HIT(0) THEN PRINT "HIT"
REM COLL. BETWEEN SPRITES 1 AND 10
IF SPRITE HIT(1,10) THEN PRINT "HIT"
REM COLL. 1 WITH ANY FROM 5 TO 10
IF SPRITE HIT(1,5 TO 10) THEN PRINT "HIT"
</pre>

<h3 id="_HIT" name="HIT">=HIT</h3>
<pre>v=HIT</pre>
<p>Returns the number of the sprite which collided with the sprite of the last call of SPRITE HIT.</p>
<pre class="exm">
IF SPRITE HIT(0) THEN
  PRINT "0 COLLIDED WITH "+HIT
END IF
</pre>

<h1 id="String-functions">String functions</h1>

<p>The following functions allow you to modify and analyze strings.</p>

<h3 id="_LEFTS" name="LEFT$">=LEFT$</h3>
<pre>s$=LEFT$(string$,number)</pre>
<p>LEFT$ returns a new string with the first <i>number</i> characters of <i>string$</i>.</p>
<pre class="exm">
PRINT LEFT$("LOWRES CODER",3)
REM >>LOW
</pre>

<h3 id="_RIGHTS" name="RIGHT$">=RIGHT$</h3>
<pre>s$=RIGHT$(string$,number)</pre>
<p>RIGHT$ returns a new string with the last <i>number</i> characters of <i>string$</i>.</p>
<pre class="exm">
PRINT RIGHT$("LOWRES CODER",5)
REM >>CODER
</pre>

<h3 id="_MID" name="MID$">=MID$</h3>
<pre>s$=MID$(string$,position,number)</pre>
<p>MID$ returns a new string with <i>number</i> characters of <i>string$</i>, starting at character <i>position</i>. The first character has the position 1.</p>
<pre class="exm">
PRINT MID$("LOWRES CODER",4,3)
REM >>RES
</pre>

<h3 id="_INSTR" name="INSTR">=INSTR</h3>
<pre>v=INSTR(string$,search$[,position])</pre>
<p>INSTR searches the first occurrence of <i>search$</i> inside of <i>string$</i> and returns its start position. If it's not found, the function returns 0.<p>
<pre class="exm">
PRINT INSTR("LOWRES CODER","RES")
REM >>4
</pre>
<p>Usually the function starts searching at the beginning of the string. Optionally it can start searching at <i>position</i>.</p>
<pre class="exm">
PRINT INSTR("LOWRES CODER","E",6)
REM >>11
</pre>

<h3 id="_CHR" name="CHR$">=CHR$</h3>
<pre>s$=CHR$(ascii)</pre>
<p>CHR$ returns a string containing one character with ASCII code <i>ascii</i>. Note that LowRes Coder's font has only a limited range of characters (english capital letters, numbers and some symbols).</p>
<pre class="exm">
FOR I=32 TO 90
  PRINT CHR$(I)
NEXT I
</pre>

<h3 id="_ASC" name="ASC">=ASC</h3>
<pre>v=ASC(string$)</pre>
<p>ASC supplies you with the ASCII code of the first character of <i>string$</i>.</p>
<pre class="exm">
PRINT ASC("L")
REM >>76
</pre>

<h3 id="_LEN" name="LEN">=LEN</h3>
<pre>v=LEN(string$)</pre>
<p>LEN returns the number of characters in <i>string$</i>.</p>
<pre class="exm">
PRINT LEN("LOWRES CODER")
REM >>12
</pre>

<h3 id="_VAL" name="VAL">=VAL</h3>
<pre>v=VAL(string$)</pre>
<p>VAL converts a number written in <i>string$</i> into a numeric value.</p>
<pre class="exm">
X=VAL("123.5")
X=X+1
PRINT X
REM >>124.5
</pre>

<h3 id="_STR" name="STR$">=STR$</h3>
<pre>s$=STR$(number)</pre>
<p>STR$ converts a number value into a string. Usually this function is not neccessary, because numbers are converted automatically to strings where needed.</p>
<pre class="exm">
PRINT STR$(255)
REM >>255
</pre>

<h3 id="_HEX" name="HEX$">=HEX$</h3>
<pre>s$=HEX$(number)</pre>
<p>HEX$ converts a number value into a hexadecimal string.</p>
<pre class="exm">
PRINT HEX$(255)
REM >>FF
</pre>

<h1 id="Maths-functions">Maths functions</h1>

<p>LowRes Coder has all maths functions of the classic BASIC programming language, and some more.</p>

<h3 id="_ABS" name="ABS">=ABS</h3>
<pre>v=ABS(x)</pre>
<p>The absolute value of <i>x</i>.</p>

<h3 id="_ATN" name="ATN">=ATN</h3>
<pre>v=ATN(x)</pre>
<p>The arctangent of <i>x</i> in radians, i.e. the angle whose tangent is <i>x</i>. The range of the function is -(PI/2) &lt; ATN(X) &lt; (PI/2).</p>

<h3 id="_COS" name="COS">=COS</h3>
<pre>v=COS(x)</pre>
<p>The cosine of <i>x</i>, where <i>x</i> is in radians.</p>

<h3 id="_EXP" name="EXP">=EXP</h3>
<pre>v=EXP(x)</pre>
<p>The exponential of <i>x</i>, i.e. the value of the base of natural logarithms (e = 2,71828...) raised to the power <i>x</i>.</p>

<h3 id="_INT" name="INT">=INT</h3>
<pre>v=INT(x)</pre>
<p>The largest integer not greater than <i>x</i>; e.g. INT(1.3) = 1 and INT(-1.3) = -2.</p>

<h3 id="_LOG" name="LOG">=LOG</h3>
<pre>v=LOG(x)</pre>
<p>The natural logarithm of <i>x</i>; <i>x</i> must be greater than zero.</p>

<h3 id="_RND" name="RND">=RND</h3>
<pre>v=RND</pre>
<p>The next number in a sequence of random numbers uniformly distributed in the range 0 &lt;= RND &lt; 1. A typical use for integer numbers looks like this:</p>
<pre class="exm">
V=INT(RND*16)
</pre>
<p>This will return an integer number from 0 to 15 (INT rounds down and RND is always less than 1.0).</p>

<h3 id="_SGN" name="SGN">=SGN</h3>
<pre>v=SGN(x)</pre>
<p>The sign of <i>x</i>: -1 if <i>x</i> &lt; 0, 0 if <i>x</i> = 0 and +1 if <i>x</i> &gt; 0.</p>

<h3 id="_SIN" name="SIN">=SIN</h3>
<pre>v=SIN(x)</pre>
<p>The sine of <i>x</i>, where <i>x</i> is in radians.</p>

<h3 id="_SQR" name="SQR">=SQR</h3>
<pre>v=SQR(x)</pre>
<p>The nonnegative square root of <i>x</i>; <i>x</i> must be nonnegative.</p>

<h3 id="_TAN" name="TAN">=TAN</h3>
<pre>v=TAN(x)</pre>
<p>The tangent of <i>x</i>, where <i>x</i> is in radians.</p>

<h3 id="_PI" name="PI">=PI</h3>
<pre>v=PI</pre>
<p>PI is the ratio of the circumference of a circle to its diameter: 3.1415926535...</p>

<h3 id="_MIN" name="MIN">=MIN</h3>
<pre>v=MIN(x,y)</pre>
<p>The MIN function returns the smallest value of two expressions.</p>

<h3 id="_MAX" name="MAX">=MAX</h3>
<pre>v=MAX(x,y)</pre>
<p>The MAX function returns the largest value of two expressions.</p>

<h3 id="_SWAP" name="SWAP">SWAP</h3>
<pre>SWAP x,y</pre>
<p>Swaps the data between any two variables of the same type (string or number).</p>
<pre class="exm">
A=10
B=40
SWAP A,B
PRINT A
PRINT B
</pre>

<h1 id="Data">Data and transfer</h1>

<p>LowRes Coder cannot load data from files, everything a program needs must be included in its source code. With the following commands you can write big lists of data and assign them easily to variables and arrays.</p>
<p>This system also allows you to transfer data between a program and the source code editor. In addition to the "Copy" and "Paste" actions in the text edit menu, there is "Copy to Transfer" and "Paste from Transfer". By selecting lines of DATA and copying them to the transfer memory, a program can read their values. And the other way around a program can write values to the transfer memory, which can be pasted as DATA commands into your source code.</p>

<h3 id="_DATA" name="DATA">DATA</h3>
<pre>DATA list</pre>
<p>Stores numeric and string constants (values, but no variables or expressions) that are accessed by the READ command. DATA commands are not executed and may be placed anywhere in the program. <i>list</i> can contain any number of constants, separated by commas.</p>
<p>READ commands access DATA in order, from the top of a program until the bottom. All constants of all DATA commands are read as one continuous list of items.</p>
<pre class="exm">DATA 10,20,30,40,50</pre>
...is exactly the same as:
<pre class="exm">
DATA 10,20,30
DATA 40,50
</pre>

<h3 id="_READ" name="READ">READ</h3>
<pre>READ list</pre>
<p>Reads values from DATA commands and assigns them to the variables in <i>list</i>. The program has an internal pointer to the current DATA value. With each value read, the pointer will move to the next DATA value.</p>
<pre class="exm">
FOR I=1 TO 3
  READ A,B$
  PRINT A+" "+B$
NEXT I 
DATA 10,"A",20
DATA "B",30,"C"
</pre>

<h3 id="_RESTORE" name="RESTORE,RESTORE TRANSFER,TRANSFER">RESTORE</h3>
<pre>RESTORE [label]</pre>
<pre>RESTORE TRANSFER</pre>
<p>Changes the internal read pointer to another position. This allows to reread data or to select specific data. If the <i>label</i> parameter is omitted, READ will start again from the top of the program. Otherwise the pointer will be set to the jump label.</p>
<pre class="exm">
RESTORE SECOND
READ A$
PRINT A$
FIRST:
DATA "ONE","TWO"
DATA "THREE"
SECOND:
DATA "FOUR","FIVE"
DATA "SIX"
</pre>
<p>RESTORE TRANSFER has a special meaning: It sets the read pointer to the beginning of the transfer memory. This is the text you can copy from your source code with the "Copy to Transfer" action in the edit menu.</p>


<h3 id="_WRITE" name="WRITE">WRITE</h3>
<pre>WRITE list</pre>
<p>Writes values to the transfer memory, which can be pasted into your source code. <i>list</i> can be any number of values or expressions, separated by commas. Each call to WRITE will add one DATA command with all its values to the transfer memory.</p>
<pre class="exm">
FOR A=1 TO 5
  WRITE A,"HI",A*5
NEXT A
</pre>
<p>After running this example program, the transfer memory will contain 5 DATA commands each with three constants.</p>

<h3 id="_WRITEDIM" name="WRITE DIM,WRITE,DIM">WRITE DIM</h3>
<pre>WRITE DIM array[,columns]</pre>
<p>Writes all elements of an array to the transfer memory. <i>array</i> is the name of a variable (without index numbers). This command adds several DATA commands to the transfer memory, each with a maximum number of <i>columns</i> values. <i>columns</i> can be a number from 0 to 16. If the parameter is omitted or 0, the default value of 8 is used.</p>
<pre class="exm">
DIM ARR(3,7)
FOR I=0 TO 3
  FOR J=0 TO 7
    ARR(I,J)=I*100+J
  NEXT J
NEXT I
WRITE DIM ARR,4
</pre>
<p>After running this example program, the transfer memory will contain 8 DATA commands each with 4 constants.</p>

<h3 id="_WRITECLEAR" name="WRITE CLEAR,WRITE,CLEAR">WRITE CLEAR</h3>
<pre>WRITE CLEAR</pre>
<p>Clears the transfer memory.</p>

<h1 id="Reserved-keywords" name="BANK,CALL,FONT,HEIGHT,INPUT,PEEK,POKE,RANDOMIZE,SCREEN,SHARED,SUB,TEMPO,TIMER,TRACE,UBOUND">Reserved keywords</h1>
<p>This is a list of all reserved keywords. They cannot be used as variable or label names.<p>
<p>* Keywords with an asterisk have no function yet, but are reserved for future versions of LowRes Coder.</p>
<p>
ABS,
AND,
ASC,
ATN,
BANK*,
BAR,
BOX,
BUTTON,
CALL*,
CHR$,
CIRCLE,
CLEAR,
CLS,
COLOR,
COS,
DATA,
DEF,
DIM,
DO,
DOWN,
ELSE,
END,
EXIT,
EXP,
FALSE,
FONT*,
FOR,
GAMEPAD,
GET,
GOSUB,
GOTO,
HEIGHT*,
HEX$,
HIT,
IF,
INPUT*,
INSTR,
INT,
LAYER,
LEFT,
LEFT$,
LEN,
LET,
LINE,
LOG,
LOOP,
MAX,
MID$,
MIN,
MOD,
NEXT,
NOT,
OFF,
ON,
OR,
PAINT,
PALETTE,
PAUSE,
PEEK*,
PERSIST,
PI,
PLOT,
POINT,
POKE*,
PRINT,
PUT,
RANDOMIZE*,
READ,
REM,
REPEAT,
RESTORE,
RETURN,
RIGHT,
RIGHT$,
RND,
SCREEN*,
SCROLL,
SGN,
SHARED*,
SIN,
SOUND,
SPRITE,
SQR,
STEP,
STR$,
SUB*,
SWAP,
TAN,
TAP,
TEMPO*,
TEXT,
THEN,
TIMER*,
TO,
TRACE*,
TRUE,
UNTIL,
UBOUND*,
UP,
VAL,
WAIT,
WEND,
WHILE,
WIDTH,
WRITE,
XOR
</p>

</body>
</html>
